#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "requests",
#     "beautifulsoup4",
#     "mutagen",
#     "rich",
#     "click",
#     "inquirer",
# ]
# ///

import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
from urllib.parse import quote_plus

import click
import inquirer
import requests
from bs4 import BeautifulSoup
from mutagen import File
from mutagen.easyid3 import EasyID3
from mutagen.easymp4 import EasyMP4
from mutagen.flac import FLAC, Picture
from mutagen.id3 import ID3, APIC, COMM, TCON, TPE2, TPOS, TPUB, TSOP, TXXX
from mutagen.mp3 import MP3
from mutagen.mp4 import MP4, MP4Cover
from mutagen.oggopus import OggOpus
from mutagen.oggvorbis import OggVorbis
from rich.console import Console
from rich.table import Table

console = Console()


class AudibleScraper:
    """Scrapes Audible.com for audiobook metadata."""
    
    BASE_URL = "https://www.audible.com"
    SEARCH_URL = f"{BASE_URL}/search?ipRedirectOverride=true&overrideBaseCountry=true&keywords="
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def search(self, query: str) -> List[Dict]:
        """Search Audible for books matching the query."""
        url = f"{self.SEARCH_URL}{quote_plus(query)}"
        console.print(f"[cyan]Searching Audible for: {query}[/cyan]")
        
        response = self.session.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        results = []
        # Find all product containers
        products = soup.find_all('li', class_='productListItem')
        
        if not products:
            # Try alternative structure
            products = soup.find_all('div', {'data-widget': 'productList'})
            if products:
                products = products[0].find_all('li', class_='bc-list-item')
        
        for product in products[:20]:  # Limit to 20 results
            try:
                result = self._parse_search_result(product)
                if result:
                    results.append(result)
            except Exception as e:
                console.print(f"[yellow]Warning: Failed to parse result: {e}[/yellow]")
        
        return results
    
    def _parse_search_result(self, product) -> Optional[Dict]:
        """Parse a single search result."""
        result = {}
        
        # Title and URL
        title_elem = product.find('h3', class_='bc-heading') or product.find('a', class_='bc-link')
        if not title_elem:
            return None
        
        if title_elem.name == 'h3':
            link = title_elem.find('a')
            if link:
                result['title'] = link.text.strip()
                result['url'] = self.BASE_URL + link.get('href', '').split('?')[0] + '?ipRedirectOverride=true&overrideBaseCountry=true'
        else:
            result['title'] = title_elem.text.strip()
            result['url'] = self.BASE_URL + title_elem.get('href', '').split('?')[0] + '?ipRedirectOverride=true&overrideBaseCountry=true'
        
        # Subtitle
        subtitle = product.find('li', class_='subtitle')
        if subtitle:
            result['title'] += f" - {subtitle.text.strip()}"
        
        # Author
        author_elem = product.find('li', class_='authorLabel')
        if author_elem:
            author_link = author_elem.find('a')
            result['author'] = author_link.text.strip() if author_link else 'Unknown'
        else:
            result['author'] = 'Unknown'
        
        # Narrator
        narrator_elem = product.find('li', class_='narratorLabel')
        if narrator_elem:
            narrator_link = narrator_elem.find('a')
            result['narrator'] = narrator_link.text.strip() if narrator_link else ''
        else:
            result['narrator'] = ''
        
        # Duration
        runtime = product.find('li', class_='runtimeLabel')
        if runtime:
            result['duration'] = runtime.text.replace('Length:', '').strip()
        else:
            result['duration'] = ''
        
        return result if result.get('title') else None
    
    def get_book_details(self, url: str) -> Dict:
        """Fetch detailed metadata for a specific book."""
        console.print(f"[cyan]Fetching book details from: {url}[/cyan]")
        response = self.session.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        details = {'url': url}
        
        # Debug: save HTML for inspection if needed
        # with open('/tmp/audible_debug.html', 'w') as f:
        #     f.write(response.text)
        
        # Cover image
        image_elem = soup.find('img', class_='bc-image-inset-border')
        if image_elem:
            cover_url = image_elem.get('src', '')
            # Upgrade to high resolution
            cover_url = cover_url.replace('_SL175_', '_SS500_').replace('_SL300_', '_SS500_')
            details['cover_url'] = cover_url
        
        # ASIN
        asin_input = soup.find('input', {'name': 'asin'})
        if asin_input:
            details['asin'] = asin_input.get('value', '')
        
        # Title and subtitle
        title_elem = soup.find('h1', class_='bc-heading')
        if title_elem:
            title_text = title_elem.text.strip()
            if ':' in title_text:
                parts = title_text.split(':', 1)
                details['title'] = parts[0].strip()
                details['subtitle'] = parts[1].strip()
            else:
                details['title'] = title_text
                details['subtitle'] = ''
        
        # Author
        author_elem = soup.find('li', class_='authorLabel')
        if author_elem:
            authors = []
            for link in author_elem.find_all('a'):
                authors.append(link.text.strip())
            details['author'] = ', '.join(authors)
            console.print(f"[dim]Debug: Found author(s): {details['author']}[/dim]")
        else:
            console.print("[dim]Debug: No authorLabel found, trying alternative selectors[/dim]")
            # Try alternative selector for author
            author_alt = soup.find('span', class_='authorLabel')
            if author_alt:
                author_text = author_alt.get_text(strip=True)
                # Clean up "By:" prefix if present
                author_text = re.sub(r'^By:\s*', '', author_text)
                details['author'] = author_text
                console.print(f"[dim]Debug: Found author via span: {details['author']}[/dim]")
        
        # Narrator
        narrator_elem = soup.find('li', class_='narratorLabel')
        if narrator_elem:
            narrators = []
            for link in narrator_elem.find_all('a'):
                narrators.append(link.text.strip())
            details['narrator'] = ', '.join(narrators)
            console.print(f"[dim]Debug: Found narrator(s): {details['narrator']}[/dim]")
        else:
            console.print("[dim]Debug: No narratorLabel found, trying alternative selectors[/dim]")
            # Try alternative selector for narrator
            narrator_alt = soup.find('span', class_='narratorLabel')
            if narrator_alt:
                narrator_text = narrator_alt.get_text(strip=True)
                # Clean up "Narrated by:" prefix if present  
                narrator_text = re.sub(r'^Narrated by:\s*', '', narrator_text)
                details['narrator'] = narrator_text
                console.print(f"[dim]Debug: Found narrator via span: {details['narrator']}[/dim]")
        
        # Series
        series_elem = soup.find('li', class_='seriesLabel')
        if series_elem:
            series_link = series_elem.find('a')
            if series_link:
                details['series'] = series_link.text.strip()
                # Try to extract book number
                series_text = series_elem.text
                match = re.search(r'Book (\d+)', series_text)
                if match:
                    details['series_part'] = match.group(1)
        
        # Categories/Genres
        categories_elem = soup.find('li', class_='categoriesLabel')
        if categories_elem:
            categories = []
            for link in categories_elem.find_all('a'):
                categories.append(link.text.strip())
            details['genre'] = '/'.join(categories[:2])  # Max 2 genres
        
        # Publisher's Summary
        summary_section = soup.find('div', class_='productPublisherSummary')
        if summary_section:
            summary_elem = summary_section.find('span', class_='bc-text')
            if summary_elem:
                details['description'] = summary_elem.text.strip()
        
        # Publisher and copyright
        copyright_elem = soup.find('p', class_='bc-text', string=re.compile(r'©'))
        if copyright_elem:
            copyright_text = copyright_elem.text.strip()
            # Extract year
            year_match = re.search(r'©(\d{4})', copyright_text)
            if year_match:
                details['year'] = year_match.group(1)
            # Extract publisher
            pub_match = re.search(r'\(P\)(\d{4})\s+(.+)', copyright_text)
            if pub_match:
                details['release_year'] = pub_match.group(1)
                details['publisher'] = pub_match.group(2).strip()
        
        # Rating
        rating_elem = soup.find('li', class_='ratingsLabel')
        if rating_elem:
            stars_elem = rating_elem.find('span', class_='bc-text')
            if stars_elem:
                rating_text = stars_elem.text.strip()
                # Extract numeric rating
                match = re.search(r'([\d.]+)', rating_text)
                if match:
                    details['rating'] = match.group(1)
        
        # Debug: Show what we collected
        console.print("[dim]Debug: Final metadata collected:[/dim]")
        for key, value in details.items():
            if value and key != 'url' and key != 'description':  # Skip URL and long description
                console.print(f"[dim]  {key}: {value}[/dim]")
        
        return details


class AudiobookTagger:
    """Updates audio files with audiobook metadata."""
    
    # Supported formats
    SUPPORTED_FORMATS = {'.mp3', '.m4b', '.m4a', '.ogg', '.oga', '.opus', '.flac', '.wma', '.aac'}
    
    def __init__(self, files: List[Path]):
        self.files = sorted(files)
        # Group files by format
        self.formats = set(f.suffix.lower() for f in self.files)
        console.print(f"[green]Found {len(self.files)} audio file(s): {', '.join(self.formats)}[/green]")
    
    def get_initial_search_query(self) -> str:
        """Extract initial search query from existing tags or filename."""
        queries = []
        
        # Debug: Show what we're working with
        console.print(f"[dim]Debug: Analyzing {self.files[0].name}[/dim]")
        
        # First try to get metadata from file tags
        for file in self.files:
            try:
                audio = File(file)
                if not audio:
                    continue
                
                # Collect all possible metadata
                album = None
                artist = None
                title = None
                albumartist = None
                
                if hasattr(audio, 'tags') and audio.tags:
                    # Try different tag formats based on file type
                    if file.suffix.lower() in ['.mp3']:
                        album = str(audio.tags.get('TALB', [''])[0]) if audio.tags.get('TALB') else None
                        artist = str(audio.tags.get('TPE1', [''])[0]) if audio.tags.get('TPE1') else None
                        albumartist = str(audio.tags.get('TPE2', [''])[0]) if audio.tags.get('TPE2') else None
                        title = str(audio.tags.get('TIT2', [''])[0]) if audio.tags.get('TIT2') else None
                    elif file.suffix.lower() in ['.m4b', '.m4a', '.aac']:
                        # M4B tags are stored differently
                        album = audio.tags.get('\xa9alb', [None])[0] if '\xa9alb' in audio.tags else None
                        artist = audio.tags.get('\xa9ART', [None])[0] if '\xa9ART' in audio.tags else None
                        albumartist = audio.tags.get('aART', [None])[0] if 'aART' in audio.tags else None
                        title = audio.tags.get('\xa9nam', [None])[0] if '\xa9nam' in audio.tags else None
                        
                        # Debug: Show what tags we found
                        console.print(f"[dim]Debug M4B tags - Album: {album}, Artist: {artist}, AlbumArtist: {albumartist}, Title: {title}[/dim]")
                        
                    elif file.suffix.lower() in ['.ogg', '.oga', '.opus', '.flac']:
                        album = audio.tags.get('album', [None])[0] if 'album' in audio.tags else None
                        artist = audio.tags.get('artist', [None])[0] if 'artist' in audio.tags else None
                        albumartist = audio.tags.get('albumartist', [None])[0] if 'albumartist' in audio.tags else None
                        title = audio.tags.get('title', [None])[0] if 'title' in audio.tags else None
                
                # Build query from available metadata
                if album:
                    # Remove CD numbers if present
                    album = re.sub(r'[- ]+cd ?\d+$', '', str(album), flags=re.IGNORECASE)
                    # Remove common audiobook suffixes
                    album = re.sub(r'\s*\(unabridged\)\s*$', '', album, flags=re.IGNORECASE)
                    album = re.sub(r'\s*\(abridged\)\s*$', '', album, flags=re.IGNORECASE)
                    
                    # Prefer albumartist over artist for audiobooks
                    if albumartist and albumartist not in ['Unknown', 'Various Artists']:
                        queries.append(f"{albumartist} {album}")
                    elif artist and artist not in ['Unknown', 'Various Artists']:
                        queries.append(f"{artist} {album}")
                    else:
                        queries.append(album)
                    
                    # If we have a good query, return it
                    if queries:
                        return queries[0]
                
                # Try title as fallback
                if title and title not in ['Unknown', 'Track']:
                    # Clean up title
                    title = re.sub(r'\s*\(unabridged\)\s*$', '', str(title), flags=re.IGNORECASE)
                    title = re.sub(r'\s*\(abridged\)\s*$', '', str(title), flags=re.IGNORECASE)
                    if artist and artist not in ['Unknown', 'Various Artists']:
                        return f"{artist} {title}"
                    return title
                
                # Just artist as last resort from tags
                if artist and artist not in ['Unknown', 'Various Artists']:
                    return str(artist)
                    
            except Exception as e:
                pass
        
        # Fallback to filename and directory parsing
        stem = self.files[0].stem
        parent_dir = self.files[0].parent.name
        console.print(f"[dim]Debug: Parsing filename: {stem}[/dim]")
        console.print(f"[dim]Debug: Parent directory: {parent_dir}[/dim]")
        
        # If parent directory looks like it might be the book title, use it
        if parent_dir and parent_dir not in ['.', '..', '/', 'audiobooks', 'Audiobooks', 'Audio.Books', 'Audio.Books.incoming', 'incoming']:
            # Clean up the parent directory name
            parent_clean = re.sub(r'[_\.]', ' ', parent_dir)
            parent_clean = re.sub(r'\s+', ' ', parent_clean).strip()
            
            # If filename is generic but parent dir is descriptive, prefer parent
            if stem.lower() in ['audiobook', 'book', 'audio', parent_clean.lower(), 'track1', 'track01', '01', '1']:
                stem = parent_clean
                console.print(f"[dim]Debug: Using parent directory as base: {stem}[/dim]")
            elif len(parent_clean) > len(stem) and parent_clean.lower() != 'audio.books.incoming':
                # Combine parent and filename if parent seems more descriptive
                stem = f"{parent_clean} {stem}"
                console.print(f"[dim]Debug: Combining parent and filename: {stem}[/dim]")
        
        # Try to extract meaningful parts from filename
        # Common patterns: "Author - Title", "Title by Author", "Title"
        
        # Remove common file numbering patterns
        stem = re.sub(r'^\d+[-_\s\.]*', '', stem)  # Remove leading numbers
        stem = re.sub(r'[-_](\d+|CD\d+|Part\d+|Chapter\d+)$', '', stem, flags=re.IGNORECASE)  # Remove trailing numbers
        
        # Try to parse "Author - Title" pattern
        if ' - ' in stem:
            parts = stem.split(' - ', 1)
            if len(parts) == 2:
                # Could be "Author - Title" or "Title - Author"
                # Usually author comes first in audiobook filenames
                return f"{parts[0].strip()} {parts[1].strip()}"
        
        # Try to parse "Title by Author" pattern
        if ' by ' in stem.lower():
            parts = stem.lower().split(' by ', 1)
            if len(parts) == 2:
                title = stem[:stem.lower().find(' by ')].strip()
                author = stem[stem.lower().find(' by ') + 4:].strip()
                return f"{author} {title}"
        
        # Clean up underscores and dots used as spaces
        stem = re.sub(r'[_\.]', ' ', stem)
        stem = re.sub(r'\s+', ' ', stem)  # Normalize multiple spaces
        
        # Remove common audiobook indicators
        stem = re.sub(r'\s*\(unabridged\)\s*$', '', stem, flags=re.IGNORECASE)
        stem = re.sub(r'\s*\(abridged\)\s*$', '', stem, flags=re.IGNORECASE)
        stem = re.sub(r'\s*audiobook\s*$', '', stem, flags=re.IGNORECASE)
        
        return stem.strip()
    
    def update_tags(self, metadata: Dict, cover_data: Optional[bytes] = None):
        """Update all audio files with the metadata."""
        console.print(f"\n[cyan]Updating {len(self.files)} file(s) with metadata...[/cyan]")
        
        # Prepare combined artist field
        artist_combined = metadata.get('author', '')
        if metadata.get('narrator'):
            artist_combined += f", {metadata['narrator']}"
        
        for i, file in enumerate(self.files, 1):
            try:
                ext = file.suffix.lower()
                
                if ext == '.mp3':
                    self._update_mp3(file, metadata, artist_combined, cover_data, i)
                elif ext in ['.m4b', '.m4a', '.aac']:
                    self._update_mp4(file, metadata, artist_combined, cover_data, i)
                elif ext in ['.ogg', '.oga', '.opus']:
                    self._update_ogg(file, metadata, artist_combined, cover_data, i)
                elif ext == '.flac':
                    self._update_flac(file, metadata, artist_combined, cover_data, i)
                else:
                    # Generic mutagen handler for other formats
                    self._update_generic(file, metadata, artist_combined, cover_data, i)
                
                console.print(f"  [green]✓[/green] Updated: {file.name}")
                
            except Exception as e:
                console.print(f"  [red]✗[/red] Failed to update {file.name}: {e}")
    
    def _update_mp3(self, file: Path, metadata: Dict, artist_combined: str, cover_data: Optional[bytes], track_num: int):
        """Update MP3 file with ID3 tags."""
        audio = MP3(file, ID3=ID3)
        
        # Clear existing tags
        audio.delete()
        audio.save()
        
        # Reload with fresh tags
        audio = MP3(file, ID3=ID3)
        
        # Set standard tags
        title = metadata.get('title', '')
        if metadata.get('subtitle'):
            title = f"{title}: {metadata['subtitle']}"
        audio['TIT2'] = title
        
        # Album
        audio['TALB'] = metadata.get('title', '')
        
        # Artists
        audio['TPE1'] = artist_combined  # Artist
        audio['TPE2'] = metadata.get('author', '')  # Album Artist
        audio['TCOM'] = metadata.get('narrator', '')  # Composer (narrator - just the name, no prefix)
        
        # Publisher
        if metadata.get('publisher'):
            audio['TPUB'] = TPUB(text=metadata['publisher'])
        
        # Year
        if metadata.get('year'):
            audio['TDRC'] = metadata['year']
        if metadata.get('release_year'):
            audio['TDRL'] = metadata['release_year']
        
        # Genre
        if metadata.get('genre'):
            audio['TCON'] = TCON(text=metadata['genre'])
        
        # Description/Comment
        if metadata.get('description'):
            audio['COMM::eng'] = COMM(
                encoding=3,
                lang='eng',
                desc='',
                text=metadata['description'][:1000]  # Limit length
            )
            audio['TXXX:DESCRIPTION'] = TXXX(
                encoding=3,
                desc='DESCRIPTION',
                text=metadata['description']
            )
        
        # Series information
        if metadata.get('series'):
            audio['TXXX:SERIES'] = TXXX(encoding=3, desc='SERIES', text=metadata['series'])
            if metadata.get('series_part'):
                audio['TXXX:SERIES-PART'] = TXXX(encoding=3, desc='SERIES-PART', text=metadata['series_part'])
                album_sort = f"{metadata['series']} {metadata['series_part']} - {metadata['title']}"
                audio['TSOP'] = TSOP(text=album_sort)
                content_group = f"{metadata['series']}, Book #{metadata['series_part']}"
                audio['TIT1'] = content_group
                audio['TXXX:MOVEMENTNAME'] = TXXX(encoding=3, desc='MOVEMENTNAME', text=metadata['series'])
                audio['TXXX:MOVEMENT'] = TXXX(encoding=3, desc='MOVEMENT', text=metadata['series_part'])
                audio['TXXX:SHOWMOVEMENT'] = TXXX(encoding=3, desc='SHOWMOVEMENT', text='1')
        
        # iTunes specific tags
        audio['TXXX:ITUNESMEDIATYPE'] = TXXX(encoding=3, desc='ITUNESMEDIATYPE', text='Audiobook')
        audio['TXXX:ITUNESGAPLESS'] = TXXX(encoding=3, desc='ITUNESGAPLESS', text='1')
        
        # Additional metadata
        if metadata.get('url'):
            audio['TXXX:WWWAUDIOFILE'] = TXXX(encoding=3, desc='WWWAUDIOFILE', text=metadata['url'])
        if metadata.get('asin'):
            audio['TXXX:ASIN'] = TXXX(encoding=3, desc='ASIN', text=metadata['asin'])
        if metadata.get('rating'):
            audio['TXXX:RATING WMP'] = TXXX(encoding=3, desc='RATING WMP', text=metadata['rating'])
        
        # Track number
        if len(self.files) > 1:
            audio['TRCK'] = f"{track_num}/{len(self.files)}"
            audio['TPOS'] = TPOS(text='1/1')
        
        # Cover art
        if cover_data:
            audio['APIC'] = APIC(
                encoding=3,
                mime='image/jpeg',
                type=3,
                desc='Cover',
                data=cover_data
            )
        
        audio.save()
    
    def _update_mp4(self, file: Path, metadata: Dict, artist_combined: str, cover_data: Optional[bytes], track_num: int):
        """Update MP4/M4B/M4A files."""
        audio = MP4(file)
        
        # Clear existing tags
        audio.clear()
        
        # Set standard tags
        title = metadata.get('title', '')
        if metadata.get('subtitle'):
            title = f"{title}: {metadata['subtitle']}"
        
        audio['\xa9nam'] = title  # Title
        audio['\xa9alb'] = metadata.get('title', '')  # Album
        audio['\xa9ART'] = artist_combined  # Artist
        audio['aART'] = metadata.get('author', '')  # Album Artist
        audio['\xa9wrt'] = metadata.get('narrator', '')  # Composer (narrator)
        
        # Year and genre
        if metadata.get('year'):
            audio['\xa9day'] = metadata['year']
        if metadata.get('genre'):
            audio['\xa9gen'] = metadata['genre']
        
        # Description/Comment
        if metadata.get('description'):
            audio['\xa9cmt'] = metadata['description'][:1000]
            audio['desc'] = metadata['description']
        
        # Publisher
        if metadata.get('publisher'):
            audio['\xa9pub'] = metadata['publisher']
        
        # Track number
        if len(self.files) > 1:
            audio['trkn'] = [(track_num, len(self.files))]
        
        # Disc number
        audio['disk'] = [(1, 1)]
        
        # iTunes specific - mark as audiobook
        audio['stik'] = [2]  # Media type: 2 = audiobook
        audio['pgap'] = True  # Gapless playback
        
        # Custom tags for series
        if metadata.get('series'):
            audio['----:com.apple.iTunes:SERIES'] = metadata['series'].encode('utf-8')
            if metadata.get('series_part'):
                audio['----:com.apple.iTunes:SERIES-PART'] = metadata['series_part'].encode('utf-8')
                audio['soal'] = f"{metadata['series']} {metadata['series_part']} - {metadata['title']}"
        
        # Additional metadata
        if metadata.get('asin'):
            audio['----:com.apple.iTunes:ASIN'] = metadata['asin'].encode('utf-8')
        if metadata.get('url'):
            audio['----:com.apple.iTunes:WWWAUDIOFILE'] = metadata['url'].encode('utf-8')
        
        # Cover art
        if cover_data:
            audio['covr'] = [MP4Cover(cover_data, imageformat=MP4Cover.FORMAT_JPEG)]
        
        audio.save()
    
    def _update_ogg(self, file: Path, metadata: Dict, artist_combined: str, cover_data: Optional[bytes], track_num: int):
        """Update OGG/Opus files."""
        audio = File(file)
        
        # Clear existing tags
        if hasattr(audio, 'clear'):
            audio.clear()
        
        # Set standard tags
        title = metadata.get('title', '')
        if metadata.get('subtitle'):
            title = f"{title}: {metadata['subtitle']}"
        
        audio['title'] = title
        audio['album'] = metadata.get('title', '')
        audio['artist'] = artist_combined
        audio['albumartist'] = metadata.get('author', '')
        audio['composer'] = metadata.get('narrator', '')
        
        # Additional metadata
        if metadata.get('year'):
            audio['date'] = metadata['year']
        if metadata.get('genre'):
            audio['genre'] = metadata['genre']
        if metadata.get('publisher'):
            audio['publisher'] = metadata['publisher']
        if metadata.get('description'):
            audio['comment'] = metadata['description'][:1000]
            audio['description'] = metadata['description']
        
        # Series information
        if metadata.get('series'):
            audio['series'] = metadata['series']
            if metadata.get('series_part'):
                audio['seriespart'] = metadata['series_part']
                audio['albumsort'] = f"{metadata['series']} {metadata['series_part']} - {metadata['title']}"
        
        # Track number
        if len(self.files) > 1:
            audio['tracknumber'] = str(track_num)
            audio['tracktotal'] = str(len(self.files))
        
        # Additional tags
        if metadata.get('asin'):
            audio['asin'] = metadata['asin']
        if metadata.get('url'):
            audio['wwwaudiofile'] = metadata['url']
        
        # Cover art handling for OGG is complex, skip for now
        # Would need to use base64 encoding in metadata
        
        audio.save()
    
    def _update_flac(self, file: Path, metadata: Dict, artist_combined: str, cover_data: Optional[bytes], track_num: int):
        """Update FLAC files."""
        audio = FLAC(file)
        
        # Clear existing tags
        audio.clear()
        
        # Set standard tags
        title = metadata.get('title', '')
        if metadata.get('subtitle'):
            title = f"{title}: {metadata['subtitle']}"
        
        audio['title'] = title
        audio['album'] = metadata.get('title', '')
        audio['artist'] = artist_combined
        audio['albumartist'] = metadata.get('author', '')
        audio['composer'] = metadata.get('narrator', '')
        
        # Additional metadata
        if metadata.get('year'):
            audio['date'] = metadata['year']
        if metadata.get('genre'):
            audio['genre'] = metadata['genre']
        if metadata.get('publisher'):
            audio['publisher'] = metadata['publisher']
        if metadata.get('description'):
            audio['comment'] = metadata['description'][:1000]
            audio['description'] = metadata['description']
        
        # Series information
        if metadata.get('series'):
            audio['series'] = metadata['series']
            if metadata.get('series_part'):
                audio['seriespart'] = metadata['series_part']
                audio['albumsort'] = f"{metadata['series']} {metadata['series_part']} - {metadata['title']}"
        
        # Track number
        if len(self.files) > 1:
            audio['tracknumber'] = str(track_num)
            audio['tracktotal'] = str(len(self.files))
        
        # Additional tags
        if metadata.get('asin'):
            audio['asin'] = metadata['asin']
        if metadata.get('url'):
            audio['wwwaudiofile'] = metadata['url']
        
        # Cover art
        if cover_data:
            picture = Picture()
            picture.type = 3  # Cover (front)
            picture.mime = 'image/jpeg'
            picture.desc = 'Cover'
            picture.data = cover_data
            audio.add_picture(picture)
        
        audio.save()
    
    def _update_generic(self, file: Path, metadata: Dict, artist_combined: str, cover_data: Optional[bytes], track_num: int):
        """Update other audio files using generic mutagen interface."""
        audio = File(file)
        if not audio:
            raise Exception(f"Unsupported format: {file.suffix}")
        
        # Try to clear existing tags
        if hasattr(audio, 'clear'):
            audio.clear()
        
        # Use common tag names
        title = metadata.get('title', '')
        if metadata.get('subtitle'):
            title = f"{title}: {metadata['subtitle']}"
        
        if hasattr(audio, 'tags') and audio.tags is not None:
            audio.tags['title'] = title
            audio.tags['album'] = metadata.get('title', '')
            audio.tags['artist'] = artist_combined
            audio.tags['albumartist'] = metadata.get('author', '')
            
            if metadata.get('year'):
                audio.tags['date'] = metadata['year']
            if metadata.get('genre'):
                audio.tags['genre'] = metadata['genre']
            if metadata.get('description'):
                audio.tags['comment'] = metadata['description'][:1000]
        
        audio.save()


def download_cover(url: str) -> Optional[bytes]:
    """Download cover image from URL."""
    try:
        console.print("[cyan]Downloading cover art...[/cyan]")
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return response.content
    except Exception as e:
        console.print(f"[yellow]Warning: Failed to download cover: {e}[/yellow]")
        return None


@click.group(invoke_without_command=True)
@click.pass_context
def cli(ctx):
    """
    Tag audio files with Audible audiobook metadata.
    
    Supported formats: MP3, M4B, M4A, OGG, OPUS, FLAC, AAC
    
    Examples:
        audtag audiobook.mp3                # Tag files with Audible metadata
        audtag info audiobook.mp3           # Show current tags
        audtag --debug audiobook.mp3        # Tag with debug output
    """
    # Store context for subcommands
    ctx.ensure_object(dict)
    
    # If no subcommand, run the default tagging behavior
    if ctx.invoked_subcommand is None:
        # Get files from remaining args
        files = ctx.args
        debug = '--debug' in ctx.args
        if debug:
            files = [f for f in files if f != '--debug']
        
        if files:
            ctx.obj['debug'] = debug
            tag_files(files, debug)
        else:
            console.print(ctx.get_help())

@cli.command()
@click.argument('files', nargs=-1, required=True, type=click.Path(exists=True))
@click.pass_context
def info(ctx, files):
    """Show metadata information for audio files."""
    audio_files = []
    for path in files:
        path = Path(path)
        if path.is_dir():
            for ext in AudiobookTagger.SUPPORTED_FORMATS:
                audio_files.extend(path.glob(f'*{ext}'))
                audio_files.extend(path.glob(f'*{ext.upper()}'))
        else:
            if path.suffix.lower() in AudiobookTagger.SUPPORTED_FORMATS:
                audio_files.append(path)
            else:
                console.print(f"[yellow]Warning: {path.name} is not a supported audio format[/yellow]")
    
    if not audio_files:
        console.print(f"[red]No supported audio files found![/red]")
        return
    
    for file_path in sorted(audio_files):
        console.print(f"\n[bold cyan]File: {file_path.name}[/bold cyan]")
        console.print(f"[dim]Path: {file_path}[/dim]")
        
        try:
            audio = File(file_path)
            if not audio or not hasattr(audio, 'tags') or not audio.tags:
                console.print("[yellow]No tags found[/yellow]")
                continue
            
            # Create a table for the tags
            tag_table = Table(show_header=False, box=None, padding=(0, 2))
            tag_table.add_column("Field", style="cyan", width=25)
            tag_table.add_column("Value", style="white")
            
            # Extract common fields based on format
            if file_path.suffix.lower() == '.mp3':
                tag_table.add_row("Title:", str(audio.tags.get('TIT2', [''])[0]) if audio.tags.get('TIT2') else '')
                tag_table.add_row("Artist:", str(audio.tags.get('TPE1', [''])[0]) if audio.tags.get('TPE1') else '')
                tag_table.add_row("Album:", str(audio.tags.get('TALB', [''])[0]) if audio.tags.get('TALB') else '')
                tag_table.add_row("Album Artist:", str(audio.tags.get('TPE2', [''])[0]) if audio.tags.get('TPE2') else '')
                tag_table.add_row("Composer (Narrator):", str(audio.tags.get('TCOM', [''])[0]) if audio.tags.get('TCOM') else '')
                tag_table.add_row("Genre:", str(audio.tags.get('TCON', [''])[0]) if audio.tags.get('TCON') else '')
                tag_table.add_row("Year:", str(audio.tags.get('TDRC', [''])[0]) if audio.tags.get('TDRC') else '')
                tag_table.add_row("Publisher:", str(audio.tags.get('TPUB', [''])[0]) if audio.tags.get('TPUB') else '')
                tag_table.add_row("Track:", str(audio.tags.get('TRCK', [''])[0]) if audio.tags.get('TRCK') else '')
                
                # Check for custom tags
                for tag_key, tag_value in audio.tags.items():
                    if tag_key.startswith('TXXX:'):
                        field_name = tag_key[5:]
                        if field_name in ['ASIN', 'SERIES', 'SERIES-PART', 'ITUNESMEDIATYPE']:
                            tag_table.add_row(f"{field_name}:", str(tag_value))
                            
            elif file_path.suffix.lower() in ['.m4b', '.m4a', '.aac']:
                tag_table.add_row("Title:", audio.tags.get('\xa9nam', [''])[0] or '' if '\xa9nam' in audio.tags else '')
                tag_table.add_row("Artist:", audio.tags.get('\xa9ART', [''])[0] or '' if '\xa9ART' in audio.tags else '')
                tag_table.add_row("Album:", audio.tags.get('\xa9alb', [''])[0] or '' if '\xa9alb' in audio.tags else '')
                tag_table.add_row("Album Artist:", audio.tags.get('aART', [''])[0] or '' if 'aART' in audio.tags else '')
                tag_table.add_row("Composer (Narrator):", audio.tags.get('\xa9wrt', [''])[0] or '' if '\xa9wrt' in audio.tags else '')
                tag_table.add_row("Genre:", audio.tags.get('\xa9gen', [''])[0] or '' if '\xa9gen' in audio.tags else '')
                tag_table.add_row("Year:", audio.tags.get('\xa9day', [''])[0] or '' if '\xa9day' in audio.tags else '')
                tag_table.add_row("Publisher:", audio.tags.get('\xa9pub', [''])[0] or '' if '\xa9pub' in audio.tags else '')
                tag_table.add_row("Track:", f"{audio.tags.get('trkn', [(0,0)])[0][0]}/{audio.tags.get('trkn', [(0,0)])[0][1]}" if 'trkn' in audio.tags else '')
                
                # Media type
                if 'stik' in audio.tags:
                    media_type = audio.tags['stik'][0]
                    media_type_str = "Audiobook" if media_type == 2 else f"Type {media_type}"
                    tag_table.add_row("Media Type:", media_type_str)
                    
            elif file_path.suffix.lower() in ['.ogg', '.oga', '.opus', '.flac']:
                tag_table.add_row("Title:", audio.tags.get('title', [''])[0] or '' if 'title' in audio.tags else '')
                tag_table.add_row("Artist:", audio.tags.get('artist', [''])[0] or '' if 'artist' in audio.tags else '')
                tag_table.add_row("Album:", audio.tags.get('album', [''])[0] or '' if 'album' in audio.tags else '')
                tag_table.add_row("Album Artist:", audio.tags.get('albumartist', [''])[0] or '' if 'albumartist' in audio.tags else '')
                tag_table.add_row("Composer (Narrator):", audio.tags.get('composer', [''])[0] or '' if 'composer' in audio.tags else '')
                tag_table.add_row("Genre:", audio.tags.get('genre', [''])[0] or '' if 'genre' in audio.tags else '')
                tag_table.add_row("Date:", audio.tags.get('date', [''])[0] or '' if 'date' in audio.tags else '')
                tag_table.add_row("Publisher:", audio.tags.get('publisher', [''])[0] or '' if 'publisher' in audio.tags else '')
                
            # Add audio properties
            if hasattr(audio.info, 'length'):
                duration = int(audio.info.length)
                hours, remainder = divmod(duration, 3600)
                minutes, seconds = divmod(remainder, 60)
                tag_table.add_row("Duration:", f"{hours:02d}:{minutes:02d}:{seconds:02d}")
            if hasattr(audio.info, 'bitrate'):
                tag_table.add_row("Bitrate:", f"{audio.info.bitrate} bps")
            if hasattr(audio.info, 'sample_rate'):
                tag_table.add_row("Sample Rate:", f"{audio.info.sample_rate} Hz")
                
            console.print(tag_table)
            
        except Exception as e:
            console.print(f"[red]Error reading file: {e}[/red]")

def tag_files(files, debug=False):
    """Main tagging functionality."""
        if path.is_dir():
            # Search for all supported formats in directory
            for ext in AudiobookTagger.SUPPORTED_FORMATS:
                audio_files.extend(path.glob(f'*{ext}'))
                audio_files.extend(path.glob(f'*{ext.upper()}'))
        else:
            # Check if file has supported extension
            if path.suffix.lower() in AudiobookTagger.SUPPORTED_FORMATS:
                audio_files.append(path)
            else:
                console.print(f"[yellow]Warning: {path.name} is not a supported audio format[/yellow]")
    
    if not audio_files:
        console.print(f"[red]No supported audio files found![/red]")
        console.print(f"[yellow]Supported formats: {', '.join(sorted(AudiobookTagger.SUPPORTED_FORMATS))}[/yellow]")
        sys.exit(1)
    
    # Initialize tagger and scraper
    tagger = AudiobookTagger(audio_files)
    scraper = AudibleScraper()
    
    # Get initial search query
    initial_query = tagger.get_initial_search_query()
    
    # Ask user for search query
    questions = [
        inquirer.Text('query', 
                     message='Search query',
                     default=initial_query)
    ]
    answers = inquirer.prompt(questions)
    
    if not answers:
        console.print("[yellow]Cancelled[/yellow]")
        sys.exit(0)
    
    search_query = answers['query']
    
    # Search Audible
    results = scraper.search(search_query)
    
    if not results:
        console.print("[red]No results found![/red]")
        sys.exit(1)
    
    # Display results
    table = Table(title="Search Results")
    table.add_column("#", style="cyan", width=3)
    table.add_column("Title", style="green")
    table.add_column("Author", style="yellow")
    table.add_column("Narrator", style="blue")
    table.add_column("Duration", style="magenta")
    
    for i, result in enumerate(results, 1):
        table.add_row(
            str(i),
            result.get('title', 'Unknown'),
            result.get('author', 'Unknown'),
            result.get('narrator', 'Unknown'),
            result.get('duration', 'Unknown')
        )
    
    console.print(table)
    
    # Let user select a result
    choices = [f"{i}. {r['title']} by {r['author']}" for i, r in enumerate(results, 1)]
    questions = [
        inquirer.List('selection',
                     message='Select audiobook',
                     choices=choices + ['Cancel'])
    ]
    answers = inquirer.prompt(questions)
    
    if not answers or answers['selection'] == 'Cancel':
        console.print("[yellow]Cancelled[/yellow]")
        sys.exit(0)
    
    # Extract selection number
    selection = int(answers['selection'].split('.')[0]) - 1
    selected = results[selection]
    
    # Get detailed metadata
    metadata = scraper.get_book_details(selected['url'])
    
    # Get current tags for comparison
    console.print("\n[cyan]Analyzing current tags...[/cyan]")
    
    # Prepare the new metadata that will be applied
    new_artist_combined = metadata.get('author', '')
    if metadata.get('narrator'):
        new_artist_combined += f", {metadata['narrator']}"
    
    new_title = metadata.get('title', '')
    if metadata.get('subtitle'):
        new_title = f"{new_title}: {metadata['subtitle']}"
    
    # Show before/after comparison
    for i, file in enumerate(tagger.files, 1):
        console.print(f"\n[bold]File {i}: {file.name}[/bold]")
        
        # Get current tags
        current_title = ""
        current_artist = ""
        current_album = ""
        current_composer = ""
        
        try:
            audio = File(file)
            if audio and hasattr(audio, 'tags') and audio.tags:
                if file.suffix.lower() == '.mp3':
                    current_title = str(audio.tags.get('TIT2', [''])[0]) if audio.tags.get('TIT2') else ''
                    current_artist = str(audio.tags.get('TPE1', [''])[0]) if audio.tags.get('TPE1') else ''
                    current_album = str(audio.tags.get('TALB', [''])[0]) if audio.tags.get('TALB') else ''
                    current_composer = str(audio.tags.get('TCOM', [''])[0]) if audio.tags.get('TCOM') else ''
                elif file.suffix.lower() in ['.m4b', '.m4a', '.aac']:
                    current_title = audio.tags.get('\xa9nam', [''])[0] or '' if '\xa9nam' in audio.tags else ''
                    current_artist = audio.tags.get('\xa9ART', [''])[0] or '' if '\xa9ART' in audio.tags else ''
                    current_album = audio.tags.get('\xa9alb', [''])[0] or '' if '\xa9alb' in audio.tags else ''
                    current_composer = audio.tags.get('\xa9wrt', [''])[0] or '' if '\xa9wrt' in audio.tags else ''
                elif file.suffix.lower() in ['.ogg', '.oga', '.opus', '.flac']:
                    current_title = audio.tags.get('title', [''])[0] or '' if 'title' in audio.tags else ''
                    current_artist = audio.tags.get('artist', [''])[0] or '' if 'artist' in audio.tags else ''
                    current_album = audio.tags.get('album', [''])[0] or '' if 'album' in audio.tags else ''
                    current_composer = audio.tags.get('composer', [''])[0] or '' if 'composer' in audio.tags else ''
        except:
            pass
        
        # Create comparison table
        compare_table = Table(show_header=False, box=None, padding=(0, 2))
        compare_table.add_column("Field", style="cyan", width=20)
        compare_table.add_column("Current", style="red", width=40)
        compare_table.add_column("→", style="white", width=3)
        compare_table.add_column("New", style="green", width=40)
        
        # Show changes
        compare_table.add_row("Title:", current_title or "(empty)", "→", new_title)
        compare_table.add_row("Artist:", current_artist or "(empty)", "→", new_artist_combined)
        compare_table.add_row("Album:", current_album or "(empty)", "→", metadata.get('title', ''))
        compare_table.add_row("Composer (Narrator):", current_composer or "(empty)", "→", metadata.get('narrator', ''))
        
        # Add additional fields that will be updated
        if metadata.get('genre'):
            compare_table.add_row("Genre:", "(not set)", "→", metadata.get('genre', ''))
        if metadata.get('publisher'):
            compare_table.add_row("Publisher:", "(not set)", "→", metadata.get('publisher', ''))
        if metadata.get('year'):
            compare_table.add_row("Year:", "(not set)", "→", metadata.get('year', ''))
        if metadata.get('series'):
            series_info = metadata['series']
            if metadata.get('series_part'):
                series_info += f", Book #{metadata['series_part']}"
            compare_table.add_row("Series:", "(not set)", "→", series_info)
        
        console.print(compare_table)
    
    # Ask for confirmation
    questions = [
        inquirer.Confirm('confirm',
                        message='Proceed with tagging?',
                        default=True)
    ]
    answers = inquirer.prompt(questions)
    
    if not answers or not answers['confirm']:
        console.print("[yellow]Cancelled[/yellow]")
        sys.exit(0)
    
    # Download cover if available
    cover_data = None
    if metadata.get('cover_url'):
        cover_data = download_cover(metadata['cover_url'])
    
    # Update tags
    tagger.update_tags(metadata, cover_data)
    
    console.print("\n[green]✅ Tagging complete![/green]")


if __name__ == '__main__':
    main()